<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>...</title> <!-- Default page title which can be overridden by query params. The title shows inside the tab button while redirecting. -->
    <link rel="icon" href="" type="image/x-icon"> <!-- Attempt to delete github favicon and use default browser icon instead. Untested. -->
    <style>
        /* Light mode styling */
        html {
            margin: 0;
            padding: 0;
            padding-left: 0.75rem;
            font-family: system-ui, -apple-system, sans-serif;
            background-color: color-mix(in srgb, white, black 0%);
            color: black
        }

        /* Dark mode styling */
        @media (prefers-color-scheme: dark) {
            html {
                background-color: color-mix(in srgb, black, white 10%);;
                color: white
            }
        }
    </style>
    
    <script>

        // Constants
        const sourceLocale = "en";
        
        // Function to get URL parameters
        function getQueryParam(param) {
            var searchParams = new URLSearchParams(window.location.search);
            return searchParams.get(param);
        }

        // Redirect to the URL specified in the 'url' query parameter
        function openURLAndCloseTab(url, postaction) {
            
            // This is copied from mac-mouse-fix-website/public/activate/index.html and then modified.
            //  Basically, we open the url, and if the redirect website is still open after the redirect (which happens if the url links into a non-browswer app such as Mail or Mac Mouse Fix), then we try to automatically close the window or navigate back in the browser history.
            // Notes:
            // - We decided against displaying "Redirecting..." in the window while redirecting. It's English so not language agnostic. I thought the blank page might be confusing to users, but it only shows up for a second.
            // - Autoclosing doesn't work when we're using the redirect-service from GitHub Markdown. 
            //  - I think it only works if the window hosting the redirect-service was opened by js or something? (That's what the messages in Safari console suggest.)
            // 
            // Notes on postactions:
            // - We only execute the postaction if the link is opened outside of the browser. E.g. a mailto: link.
            // - close postaction: The 10ms delay before installing onfocus is necessary for Firefox to not close immediately
            // - back postaction: When building back postaction, the 10ms delay didn't seem to be necessary for Firefox. Maybe Firefox fixed things? Idk. but the 10ms delay doesn't hurt so leaving it.
            // - any postaction:
            //    - We want the redirect window to close/goback immediately after opening the URL. But not before opening the url. 
            //    - We achieve something somewhat close to that with the window.onfocus() callbacks. 
            //        - In Chrome, those callbacks don't trigger immediately after opening the app, instead they only open after you click the window which displays the redirect page after the app has been opened. 
            //        - In Safari, we see the same behaviour as Chrome if the user has clicked 'Always Allow' in the 'Allow <website> to open <app>?' dialog. However, if the user manually clicks 'Allow' in that dialog, the window.onfocus() callback will trigger immediately after the url is openend, which is the ideal behaviour we want.
            //            - To reset the 'Always Allow' choice in Safari, you need to manually edit ~/Library/Safari/PerSitePreferences.db. See: https://apple.stackexchange.com/questions/465335/how-to-retract-always-allow-safari-permission-for-opening-app
            //        - We used to autoclose the redirection window after 5s to make it a bit better, but that also closes the window while the 'Allow <website> to open <app>?' dialog is still open, which would be annoying if the user is still trying to read the dialog.

            // Validate
            if (url == undefined) {
                document.getElementById("message").innerText += `Target url is undefined`;
                return;
            }
            if (url.includes(window.location.hostname) && (false)) { 
                // Note: 
                //     Turning this validation off since it triggers when redirecting to feedback-assistant (as of 30.08.2024)
                //     Why did I ever think this is a problem?
                document.getElementById("message").innerText += `Target url ${url} contains current hostname`;
                return;
            }

            // TESTING
            //  
            //  Tested using URL: 
            //      file:///Users/Noah/Desktop/mmf-stuff/redirection-service/index.html?target=mmfl-activate
            //  To reset always-allow:
            //      Safari: 
            //          https://apple.stackexchange.com/questions/465335/how-to-retract-always-allow-safari-permission-for-opening-app
            //          (Use this SQL command: DELETE FROM preference_values WHERE preference_value == 'macmousefix')
            //      Chrome:
            //          chrome://settings/clearBrowserData
            //      Firefox: 
            //          Click the thing in the url bar.
            //  
            //  Documenting console logs during different interactions:
            //      (Last updated: 02.09.2024)
            //      Safari:
            //          not-always-allow:
            //           - page/dialog open -> nothing
            //           - first input -> `blur` 
            //                 (input can be mouse move/click, or keyboard press)
            //                  >~ 300ms after addEventListener()
            //           - dialog click 'allow' -> `focus`
            //           - dialog click 'cancel' -> `focus`
            //           - dialog click 'always allow' -> `focus`
            //           - window click after app open -> `focus`
            //                (Seems like this can produce double `focus` log without `blur` log in between, which is weird. (02.09.2024))
            //          always-allow:
            //           - page/app open -> `blur`
            //                  <~ 100ms after addEventListener()
            //           - window click after app open -> `focus`
            //      Chrome 
            //          not-always-allow:
            //           - page/dialog open -> `blur`
            //              <~ 25ms after addEventListener()
            //           - page reload with open dialog -> nothing (feels like a bug)
            //           - dialog click 'allow' -> 'Launched external handler for 'macmousefix:activate'.'
            //           - dialog click 'cancel' -> `focus`
            //           - dialog click with 'always allow' selected -> same as normal 'allow' and 'cancel'.
            //           - window click after app open -> `focus`
            //          always-allow:
            //           - page/app open -> `blur` and `Launched external handler for 'macmousefix:activate'.`
            //              <~ 50ms after addEventListener()
            //           - window click after app open -> `focus`
            //      Firefox:
            //          not-always-allow:
            //              - page/dialog open -> `focus` AND `blur`
            //                  -> `focus` ~< 5ms, `blur` ~< 10 ms after addEventListener()
            //              - page reload with open dialog -> nothing (same weirdness as Chrome)
            //              - dialog click 'allow' -> `focus` AND `blur`
            //              - dialog click 'cancel' -> `focus`
            //              - dialog click with 'always allow' selected -> same as normal 'allow' and 'cancel'
            //              - window click after app open -> `focus`
            //          always-allow:
            //              - page/app open -> `focus` AND `blur`
            //                  `focus` ~< 5ms, `blur` ~< 40 ms after addEventListener()
            //              - window click after app open -> `focus`
            //      
            //      -> They all behave pretty different. Firefox is the only one where the logic seems consistent.
            //      -> Our goal is to detect when the url was opened, and then execute the post-action. 
            //          Do we have enough information to do this on every browser?
            //          Safari: 
            //              - When window.onblur is triggered immediately after page load, we know we're in the always-allow case, then we can just immediately do the post-action.
            //              - When there's a delay before window.onblur, we're in the `not-always-allow` case. Then we can wait for the next window.onfocus() before we do the post-action.
            //          Chrome: 
            //              - Chrome logs "Launched external handler for 'macmousefix:activate'." right when it opens the url. We can simply do the post-action right after that, if we can intercept the logs.
            //          Firefox:
            //              - The only way I see to differentiate between the "`focus` AND `blur`" that happens when the dialog opens vs the "`focus` AND `blur` when the app is opened in the 'always-allow' case is the 
            //                  slight timing difference of `blur`. However, this seems very non-robust, since we have to normalize the timing based on CPU Speed somehow. I could divide blurtime / focustime, to normalize, which
            //                  might work well but might also break in edge cases or when the performance characteristics of a users system are very different. And if Firefox gets optimized, that could also break the thing.
            //          Update: 
            //                I don't think any of this is robust. I cannot find a way to intercept the Chrome logs. (I can swap out console.log for my own implementation but this doesn't affect the logs produced by Chrome.)
            //                  All the other stuff is timing-based heuristics with not that much difference between the timings. (If it was a huge difference like 1ms vs 1000ms, I'd be ok with the heuristic I think but it's 10ms vs 40ms on FF, 100ms vs >= 300ms on Safari, and 25ms vs 50ms on Chrome. I don't feel confident using any of that.)
            //                  -> Soooo we'll give up on the idea of doing the post-action immediately after redirect page has opened an app/been dismissed by the user.
            //         
            //                Alternative approaches I considered: 
            //                      navigator.permissions.query() lets you query certain permissions but not app-opening permissions (as of 02.09.2024)
            //                      We tried monitoring other events than onblur and onfocus to maybe establish a 'baseline' for the timing heuristics to increase their accuracy, but the only other event I could find that fires is `window.onpageshow()` and that always fires within 0ms or 1ms, so not useful for establishing the baseline.

            if (true) {
                
                // Test permissions API
                if (false) {
                    navigator.permissions.query({ name: 'geolocation' }).then((result) => {
                        console.log(`Permissions API test: ${result.state}`);
                    })
                }
                
                // Get ts
                const tsStart = Date.now();

                //  Setup visibility change callback
                document.addEventListener('visibilitychange', () => {
                    console.log(`visiblity: ${document.visibilityState}`); // 'visible' or 'hidden'
                });

                // Setup other event intercepts
                //   We might use this as a timing baseline for the blur/focus events
                if (false) {
                    window.oncancel = () => {
                        console.log(`cancel`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onclick = () => {
                        console.log(`click`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onload = () => {
                        console.log(`load`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onloadstart = () => {
                        console.log(`loadstart`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onloadeddata = () => {
                        console.log(`loadeddata`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onloadedmetadata = () => {
                        console.log(`loadedmetadata`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onpageshow = () => {
                        console.log(`pageshow`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onrejectionhandled = () => {
                        console.log(`rejectionhandled`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onwaiting = () => {
                        console.log(`waiting`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onstalled = () => {
                        console.log(`stalled`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    window.onsecuritypolicyviolation = () => {
                        console.log(`securitypolicyviolation`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onblur = () => {
                        console.log(`dblur`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onfocus = () => {
                        console.log(`dfocus`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onended = () => {
                        console.log(`dended`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.oncuechange = () => {
                        console.log(`doncuechange`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.oninput = () => {
                        console.log(`dinput`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onload = () => {
                        console.log(`dload`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onloadstart = () => {
                        console.log(`dloadstart`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onloadeddata = () => {
                        console.log(`dloadeddata`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                    document.onloadedmetadata = () => {
                        console.log(`dloadedmetadata`);
                        console.log(`   -> ${Date.now() - tsStart}ms`);
                    }
                }

                // Setup blur/focus intercept
                window.onblur = () => { 
                    console.log(`blur`);
                    console.log(`   -> ${Date.now() - tsStart}ms`);
                };
                window.onfocus = () => {

                    console.log(`focus`);
                    console.log(`   -> ${Date.now() - tsStart}ms`);
                };

                // Setup console.log intercept
                if (false) {
                    (function() {
                        var exLog = console.log;
                        console.log = function(msg) {
                            exLog.call(console, '(intercepted:)')
                            exLog.apply(console, arguments);
                        }
                    })()

                    console.log(`testtt`);
                }
            }

            // Redirect
            window.location.href = url;

            // TEST
            //  Simulate escape-press
            // (Doesn't do anything to the dialog.)
            if (false) {
                setTimeout(() => {
                    console.log(`Simulating escape-press...`);
                    window.dispatchEvent(
                        new KeyboardEvent("keydown", {
                            altKey: false,
                            code: "Escape",
                            ctrlKey: false,
                            isComposing: false,
                            key: "Escape",
                            location: 0,
                            metaKey: false,
                            repeat: false,
                            shiftKey: false,
                            which: 27,
                            charCode: 0,
                            keyCode: 27,
                        })
                    );
                }, 500);
            };

            // Post-action
            
            return; // TESTING

            if (postaction == "close") {
                // Install onblur listener
                window.onblur = () => { window.close(); };
                // Install onfocus listener
                //    After 10ms
                setTimeout(function () { window.onfocus = function () { 
                    window.close(); 
                }; }, 10);    
            } else if (postaction == "back") {
                setTimeout(function () { window.onfocus = function () { window.history.back(); }; }, 10);    // Install onfocus listener after 10ms
            }
        }

        function redirect() {

            // Parse params
            var target = getQueryParam("target");
            var customPageTitle = getQueryParam("page-title");
            var customMessage = getQueryParam("message");
            var locale = getQueryParam("locale");
            if (!target) {
                document.getElementById("message").innerText += "No redirection target provided!";
                return
            }
            if (customMessage) {
                document.getElementById("message").innerText += decodeURIComponent(customMessage);
            }
            if (customPageTitle) {
                document.title = customPageTitle; // Not sure this works, I haven't tested.
            }
            
            // Map target to url
            var urlMap = {
                /// `macmousefix:` links
                "mmfl-activate": "macmousefix:activate",
                /// Non-browser:
                "macos-settings-loginitems": "x-apple.systempreferences:com.apple.LoginItems-Settings.extension",
                "mailto-noah": "",
                /// MMF:
                "mmf-github-readme": "https://github.com/noah-nuebling/mac-mouse-fix/",
                "mmf-acknowledgements": "https://github.com/noah-nuebling/mac-mouse-fix/blob/master/Acknowledgements.md",
                "mmf-about": "https://github.com/noah-nuebling/mac-mouse-fix",
                "mmf-questions": "https://github.com/noah-nuebling/mac-mouse-fix?tab=readme-ov-file#questions",
                "mmf2-latest": "https://github.com/noah-nuebling/mac-mouse-fix/releases/tag/2.2.4",
                /// MMF Feedback:
                "mmf-feedback-bug-report": "https://noah-nuebling.github.io/mac-mouse-fix-feedback-assistant/?type=bug-report",
                "mmf-feedback-feature-request": "https://noah-nuebling.github.io/mac-mouse-fix-feedback-assistant/?type=feature-request",
                "mmf-feedback-other": "https://noah-nuebling.github.io/mac-mouse-fix-feedback-assistant/?type=other",
                /// MMF Guides:
                "mmf-localization-guide": "https://github.com/noah-nuebling/mac-mouse-fix/discussions/731", 
                "mmf-ventura-enabling-guide": "https://github.com/noah-nuebling/mac-mouse-fix/discussions/861", 
                "mmf-guides": "https://github.com/noah-nuebling/mac-mouse-fix/discussions/categories/guides",
                "mmf-compatibility-guide": "https://github.com/noah-nuebling/mac-mouse-fix?tab=readme-ov-file#macos-compatibility",
                "mmf-captured-buttons-guide": "https://github.com/noah-nuebling/mac-mouse-fix/discussions/112",
            };

            // Override map 
            //    for specific locale
            if (locale != null && locale != sourceLocale) {

                // MMF:
                urlMap["mmf-github-readme"] = `https://github.com/noah-nuebling/mac-mouse-fix/blob/master/Markdown/LocalizedDocuments/${locale}/Readme.md`;
                urlMap["mmf-acknowledgements"] = `https://github.com/noah-nuebling/mac-mouse-fix/blob/master/Markdown/LocalizedDocuments/${locale}/Acknowledgements.md`;
                urlMap["mmf-about"] = `https://github.com/noah-nuebling/mac-mouse-fix/blob/master/Markdown/LocalizedDocuments/${locale}/Readme.md`;
                urlMap["mmf-questions"] = `https://github.com/noah-nuebling/mac-mouse-fix/blob/master/Markdown/LocalizedDocuments/${locale}/Readme.md#questions`;
                urlMap["mmf2-latest"] = `https://github.com/noah-nuebling/mac-mouse-fix/releases/tag/2.2.4`; // TODO: Update if/when we localize

                // MMF Feedback:
                //    Note: We don't need to localize this since feedback-assistant supports js and can set localization itself based on browser settings.
                
                // MMF Guides:
                urlMap["mmf-guides"] = `https://github.com/noah-nuebling/mac-mouse-fix/discussions/categories/guides`; // TODO: Update if/when we localize
                urlMap["mmf-compatibility-guide"] = `https://github.com/noah-nuebling/mac-mouse-fix/blob/master/Markdown/LocalizedDocuments/${locale}/Readme.md#macos-compatibility`; // Note: The #macos-compatibility fragment works in any language, because we added non-localized anchor links to the .md files (such as `<a name="macos-compatibility"></a>`)
                urlMap["mmf-captured-buttons-guide"] = `https://github.com/noah-nuebling/mac-mouse-fix/discussions/112`; // TODO: Update once we localize this.
            }
            
            var url;
            if (Object.hasOwn(urlMap, target)) {

                if (target == "mailto-noah") {
                    // Handle email separately from urlMap to prevent automatic crawling of the address, and to allow custom param for prefilling email subject.
                    const subject = encodeURIComponent(getQueryParam("subject") ?? "");
                    const body = encodeURIComponent(getQueryParam("body") ?? "");
                    const e1 = "com"; const e2 = "gmail"; const e3 = "public"; const e4 = ".n"; const e5 = "noah";
                    url = `mailto:${e5}${e4}.${e3}@${e2}.${e1}?subject=${subject}&body=${body}`;
                } else {
                    url = urlMap[target];
                }
            } else {
                document.getElementById("message").innerText += `Unknown redirection target "${target}". Known targets:\n${Object.keys(urlMap)}`;
                return;
            }

            // Decide what to do after redirect

            var postaction = null
            
            const urlScheme = url.split(':')[0]
            const urlOpensInBrowser = (urlScheme == 'http' || urlScheme == 'https')
            const urlIsInvalid = (urlScheme == '' || urlScheme == null)
            
            if (urlIsInvalid) {
                document.getElementById("message").innerText += `Unknown url scheme "${urlScheme}". url: ${url}`;
                return;
            }
            if (urlOpensInBrowser) {
                postaction = "nothing";
            } else {
                postaction = window.history.length > 1 ? "back" : "close";
            }

            // Open url
            openURLAndCloseTab(url, postaction);
        }
    </script>
</head>

<body onload="redirect()">
    <p id="message"></p>
</body>
</html>
